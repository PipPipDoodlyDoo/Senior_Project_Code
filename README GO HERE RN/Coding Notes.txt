Trivial Notes:
PRINT
	print("string ", variable)					# Didn't need the +str() function
	
Functions:
	for a while loop or for loop there are no {} to define the scope of the function
	instead they use indentation.
	
	Example:
		for x in range (21):					# They use Semicolon to start the for loop.
			i = x+i						
			
Formatting
	for ADC when displaying the Analog Voltage & want to show only 2 decimal on print
	use print('{:.2f}'.format(variable))
___________________________________________________________________________
For a basic GPIO

Pin Notes (https://docs.micropython.org/en/latest/library/machine.Pin.html):
    Can be used as input or output
		output_p#_name = Pin(#,Pin.OUT)			# Set GPIO Output
		output_p#_name = Pin(#,Pin.IN)			# Set GPIO Input
	

	There is a Pull_UP or Pull_DOWN Resistor Functionality
		P#_name = Pin(#, Pin.IN, Pin.PULL_UP)	# Set GPIO Input to Pull Up
		P#_name = Pin(#, Pin.IN, Pin.PULL_DOWN)	# Set GPIO Input to Pull Down
	
	Set the !OUTPUT! GPIO High or LOW
		output_p#_name.value(1)					# Set Output Pin High
		output_p#_name.value(0)					# Set Output Pin Low
		
	You can reconfigure the pin
		reference the document
	
	The LED is on pin 25
	
Code:
from machine import Pin             			# Importing the python library

LED = Pin(25, Pin.OUT)							# Initializing the Pin directionality and number to variable LED
LED.value(1)									# Set the led pin high
LED.value(0)									# Set the LED pin Low
__________________________________________________________________________________________

Analog-to-Digital Converter

Notes:
	There are 3 channels for external ADC use:
		[0, 1, 2]
	The 4th channel is used for internal temperature
	
	The correlating pins for ADC are:
		[26, 27, 28]
	
		import machine
	
	FOR THIS YOU JUST USE:
		adc.read_u16()							# This should give a 16 bit digital voltage

Code:
	from machine import ADC, Pin				# Including the library to the project
	ADC = ADC(Pin(26))							# Initializing Pin 26 to do ADC
	ADC.read_u16()								# Read the ADC pin
	
More Notes:
	For more control use ADCBlock (Don't know if Pycharm supports this in its package
		
Code:
	from machine import ADCBlock

	block = ADCBlock(id, bits=12)  				# create an ADCBlock with 12-bit resolution
	adc = block.connect(4, pin)    				# connect channel 4 to the given pin
	val = adc.read_uv()            				# read an analog value

Notes for Coding:
	I think the formula from converting the digital value back to analog is:
		Analog = Reference_Voltage / (2^N - 1) * Digital_Value
		
	The reference voltage for Raspberry Pi Pico is 3.3V
	N is 16 because of "read_U16" meaning 16-bits therefore N is 65536
	The denominator is total 65535
	Digital value is ADC Reading
	
___________________________________________________________________________
Threading

Description: 
	This is running multiple instructions of code simultaneously. Within the circuitdigest documentation of
	"multicore" processing, it says that there is one thread per core for the RP2040.
	
	(https://circuitdigest.com/microcontroller-projects/dual-core-programming-on-raspberry-pi-pico-using-micropython)
	
Notes:
	Library to access "multicore" or threading is "_thread" so the code to import would look like
		import _thread
	https://mpython.readthedocs.io/en/master/library/micropython/_thread.html						# URL to view the library package content
	
	I think the second thread (Core 1) would just be running the ADC intakes and writing to the memory via pointer
		
Code:
	_thread.start_new_thread(function,arg())
___________________________________________________________________________
How to use functions and global:
Notes:
	On the main script they are Global functions. But if you want to change variables value
	you would have to use the global command.
	
code:
	import math
	x = 1							# Arbitrary value
	
	def change value
		x = 2						# This will change the value of x within the function
									# as soon as function is over it changes back to 1
		global x 					# For Pycharm you have to define the Global variable then write to it
		
		x = 3						# this changes x value internally and externally of the function
		
___________________________________________________________________________
Switch Case
Notes:
	It says that for Python 3.10+ we can use match argument
	
Code:
	def number_to_string(argument):
		match argument:
			case 0:
				return "zero"
			case 1:
				return "one"
			case 2:
				return "two
	
	if _name_ = "_main_"
		argument = 0
		number_to_string(argument)
___________________________________________________________________________
Dictionaries
Notes:
    Just like in C/C++ you would use #define to macro everything
    In Python there is no code to implement that but there are dictionaries
    that you can use.

Code:
    thisdict = {
        "brand": "Ford",
        "model": "Mustang",
        "year": 1964
    }

    # to access that value we do

    thisdict["brand"]
___________________________________________________________________________
Lists
    This can be utilize with organizing the old data and comapring it to the new
    Mostly during the calibration stage we will check if the 2 values are increasing or decreasing
    This will tell us what end of the slope we are on.

___________________________________________________________________________
for loops
Notes:
    The syntax for this
Code:
    thislist = ["apple", "banana", "cherry"]

    for x in thislist:
        print(x)

___________________________________________________________________________
Logic Operators
Notes:
    you can run multiple checks on an If Statement by using 'and'/'or'

Code:
    if ((case 1) and (case 2)):     # Pretty sure you can extend out later on and cascade test
    if ((x > 3) or (y < 2)):

___________________________________________________________________________
Interrupt
Notes:
    This will be dedicated to only pin because that is what we are working with
    The different triggers for Pin
        -Pin.IRQ_FALLING
        -Pin.IRQ_RISING
        -Pin.IRQ_LOW_LEVEL
        -Pin.IRQ_HIGH_LEVEL
        (These values can be OR'ed together to have multiple triggers.
___________________________________________________________________________

AD8302 Notes:
	As for the AD8302, the Phase Difference graph shows a parabolic function. This is un-advantageous
		because at 0 degrees we do now know whether this is positive or negative phase shift
	If we can craft the hardware components to have a default of 90 phase shift then we can use that slope.
		Ideally it should cover the 90 degree phase shift
	
Code Notes:
	For this project we will be using the phase at difference originally set at 90 degrees which is looking 12 o'clock
    This will cover the whole sweep of direction which that we are just looking right in front of us.


___________________________________________________________________________
Testing Notes:
    - As for the ADC, when converting the digital to analog value for the voltage, Channel 0 (pin 26) is 20 mV higher. May need to take that
        to consideration depending on the sensativity when it comes to the direction to heading.

___________________________________________________________________________
Implementation Notes
Phase Array:
    On the website; https://www.radartutorial.eu/06.antennas/Phased%20Array%20Antenna.en.html
    they talked about phase array and their equation came to:
        phi = 360 * d * sin(theta) / lambda
            phi     ~ Phase Shift between 2 successive elements (phase difference between antenna)
            d       ~ Distance between the antenna [meters]
            theta   ~ beam direction
            lambda  ~ wavelength which is 1.811 meters

            *All calculation are calculations are done in degree

    Now the equation to get Beam Direction from Phase shift is:
        theta = asin((phi * lambda) / (360 * d))
Theory:
    If my thinking is right then the beam directoin (theta) should come from straight on.
    Therefore the 12 o'clock direction should be 0 degree which means that this is
Hardware:
    As we sample the output AD8302 in Volts, we go from Digital Volts -> Analog Voltage -> Degrees
    As for the heading:
     9 o'clock: 180 to 165      6
    10 o'clock: 165 to 135      5
    11 o'clock: 135 to 105      4
    12 o'clock: 105 to  75      3
     1 o'clock:  75 to  45      2
     2 o'clock:  45 to  15      1
     3 o'clock:  15 to   0      0

___________________________________________________________________________
Notes to do:
    -[] Later whether we use a LCD or a UART Terminal, all the print would change to
        Serial writes. "writing to the user"
    -[] During the Calibration values we have initial zero and we can find the degree offset from 2 successive elements and
        then with the Magnitude output ratio we can find
    -[] We will compare the difference of phase offset between the measured and calibrated value.
    -[] May have to incorporate another ADC for the reference Output of AD8302
    -[] With finding whether the direction is left or right with using magnitude difference. If postive then INPA is higher than INPB
        In a scenario, left antenna is INPA then this would mean the collar is in the left hand plane.
    -[] Need to worry about if i hit the maximum output of phase pin which is in-phase input.